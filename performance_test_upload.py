import subprocess
import os
import re
import time
import statistics
import random
import string

def run_command_in_background(command):
    """Run a command in the background using subprocess.Popen."""
    print(f"Starting command: {command}")
    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    return process

def run_command(command):
    """Run a command and wait for it to complete, returning elapsed time."""
    print(f"Executing: {command}")
    start_time = time.time()
    result = subprocess.run(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    end_time = time.time()
    elapsed_time = end_time - start_time

    if result.returncode != 0:
        print(f"Error: Command '{command}' failed with error:\n{result.stderr.decode('utf-8')}")
    else:
        print(f"Success: {result.stdout.decode('utf-8')}")

    return elapsed_time

def save_performance_results(file_name, total_time, avg_time, throughput, client_num, file_size_kb):
    """Save the performance results to a file inside the performance_results folder."""
    # Ensure the performance_results folder exists
    if not os.path.exists("performance_results"):
        os.makedirs("performance_results")

    # Construct the full file path within the folder
    file_path = os.path.join("performance_results", file_name)

    # Save the results to the file
    with open(file_path, "w") as f:
        f.write("Performance Metrics\n")
        f.write(f"Total Files Uploaded: {client_num}\n")
        f.write(f"File Size: {file_size_kb} KB\n")
        f.write(f"Total Time Taken: {total_time:.2f} seconds\n")
        f.write(f"Average Upload Time: {avg_time:.2f} seconds\n")
        f.write(f"Throughput: {throughput:.2f} KB/s\n")
    print(f"Performance results saved to {file_path}")

def generate_utf8_file(file_name, file_size_kb):
    """Generate a file with valid UTF-8 text content."""
    chars = string.ascii_letters + string.digits + " \n"
    total_chars = file_size_kb * 1024
    with open(file_name, "w", encoding="utf-8") as f:
        f.write("".join(random.choices(chars, k=total_chars)))

def cleanup_directories(commands):
    """Remove directories generated by the chunkserver based on IP:Port."""
    pattern = r"(\d+\.\d+\.\d+\.\d+:\d+)"
    for cmd in commands:
        match = re.search(pattern, cmd)
        if match:
            directory = match.group(1).replace(":", "_")
            os.system(f"rm -rf {directory}")
            print(f"Removed directory: {directory}")

def main():
    # Configuration
    client_num = 5
    file_size_kb = 2
    sleep_interval = 1

    # Step 1: Start Master nodes
    print("Starting Master nodes...")
    master_commands = [
        "target/release/master -a 127.0.0.1:50001",
        "target/release/master -a 127.0.0.1:50002",
        "target/release/master -a 127.0.0.1:50003"
    ]
    master_processes = [run_command_in_background(cmd) for cmd in master_commands]

    # Step 2: Start ChunkServer nodes and cleanup directories
    print("Starting ChunkServer nodes...")
    chunkserver_commands = [
        "target/release/chunkserver -a 127.0.0.1:50010",
        "target/release/chunkserver -a 127.0.0.1:50011"
    ]
    cleanup_directories(chunkserver_commands)
    chunkserver_processes = [run_command_in_background(cmd) for cmd in chunkserver_commands]

    time.sleep(2)  # Wait for servers to stabilize

    # Step 3: Upload Performance Test
    print("Starting upload performance test...")
    upload_times = []
    for i in range(client_num):
        file_name = f"test_file_{i}.txt"
        generate_utf8_file(file_name, file_size_kb)

        upload_command = f"target/release/client upload {file_name}"
        elapsed_time = run_command(upload_command)
        upload_times.append(elapsed_time)

        os.remove(file_name)
        print(f"Cleaned up local file: {file_name}")
        time.sleep(sleep_interval)

    # Step 4: Calculate and save metrics
    total_time = sum(upload_times)
    avg_time = statistics.mean(upload_times)
    throughput = (client_num * file_size_kb) / total_time

    print("\nPerformance Metrics:")
    print(f"Total Files Uploaded: {client_num}")
    print(f"File Size: {file_size_kb} KB")
    print(f"Total Time Taken: {total_time:.2f} seconds")
    print(f"Average Upload Time: {avg_time:.2f} seconds")
    print(f"Throughput: {throughput:.2f} KB/s")

    save_performance_results("performance_upload_results.txt", total_time, avg_time, throughput, client_num, file_size_kb)

    # Step 5: Terminate processes
    print("Shutting down Master and ChunkServer nodes...")
    for process in master_processes + chunkserver_processes:
        process.terminate()

if __name__ == "__main__":
    main()
